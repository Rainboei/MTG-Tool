# Mana color mapping for shorthand and full names
MANA_COLORS = {"White": "W", "Blue": "U", "Black": "B", "Red": "R", "Green": "G", "Colorless": "C"}
MANA_COLOR_MAP = {**MANA_COLORS, **{v: k for k, v in MANA_COLORS.items()}}  # Bidirectional mapping


def normalize_mana_color(input_color):
    """
    Normalize a mana color input to its shorthand representation.
    If the input is already shorthand, return it as is.
    """
    if input_color in MANA_COLOR_MAP:
        # Always return the shorthand version
        return MANA_COLORS.get(input_color, input_color)
    else:
        raise ValueError(f"Invalid mana color: {input_color}")


class ManaPool:
    """
    Represents a player's mana pool.
    Supports adding, spending, and resetting mana of all valid colors.
    """
    def __init__(self):
        self.pool = {color: 0 for color in MANA_COLORS.values()}

    def add_mana(self, color, amount=1):
        normalized_color = normalize_mana_color(color)
        if normalized_color in self.pool:
            self.pool[normalized_color] += amount
            print(f"Added {amount} {MANA_COLOR_MAP[normalized_color]} mana. Current mana pool: {self}")
        else:
            print(f"Invalid mana color: {color}")

    def spend_mana(self, cost):
        """
        Spend mana from the pool if sufficient mana is available.
        The cost is a dictionary: {"White": 1, "Green": 2, ...}.
        """
        normalized_cost = {normalize_mana_color(color): amount for color, amount in cost.items()}

        # Check if the cost can be paid
        for color, amount in normalized_cost.items():
            if self.pool.get(color, 0) < amount:
                print(f"Not enough {MANA_COLOR_MAP[color]} mana to pay the cost!")
                return False

        # Deduct the mana
        for color, amount in normalized_cost.items():
            self.pool[color] -= amount
        print(f"Mana spent: {normalized_cost}. Remaining pool: {self}")
        return True

    def reset_pool(self):
        self.pool = {color: 0 for color in self.pool}
        print("Mana pool has been reset.")

    def __str__(self):
        return ", ".join(f"{color}: {amount}" for color, amount in self.pool.items() if amount > 0)


class Card:
    """
    Represents a card with a name, cost, and type.
    """
    def __init__(self, name, cost, card_type):
        self.name = name
        self.cost = {normalize_mana_color(color): amount for color, amount in cost.items()}
        self.card_type = card_type
        self.tapped = False
        self.zone = "Library"

    def is_playable(self, mana_pool):
        for color, amount in self.cost.items():
            if mana_pool.pool.get(color, 0) < amount:
                return False
        return True

    def __str__(self):
        cost_str = ", ".join(f"{MANA_COLOR_MAP[color]}: {amount}" for color, amount in self.cost.items() if amount > 0)
        tapped_status = "Tapped" if self.tapped else "Untapped"
        return f"{self.name} ({self.card_type}) - Cost: {cost_str}, Status: {tapped_status}, Zone: {self.zone}"


class Player:
    """
    Represents a player with a mana pool, hand, library, battlefield, and graveyard.
    """
    def __init__(self, name):
        self.name = name
        self.life_total = 20
        self.mana_pool = ManaPool()
        self.library = []
        self.hand = []
        self.battlefield = []
        self.graveyard = []

    def draw_card(self):
        """Draw a card from the library and add it to the hand."""
        if self.library:
            card = self.library.pop(0)
            self.hand.append(card)
            card.zone = "Hand"
            print(f"{self.name} drew {card.name}.")
        else:
            print(f"{self.name} has no cards left in the library!")

    def play_card(self, card):
        """
        Attempt to play a card from the hand. If successful, pay its cost and move it to the battlefield.
        """
        if card in self.hand and card.is_playable(self.mana_pool):
            self.mana_pool.spend_mana(card.cost)
            self.hand.remove(card)
            self.battlefield.append(card)
            card.zone = "Battlefield"
            print(f"{self.name} played {card.name}.")
        else:
            print(f"{self.name} cannot play {card.name} (not enough mana or not in hand).")

    def __str__(self):
        """Return the player's current state."""
        return (f"Player: {self.name}, Life Total: {self.life_total}\n"
                f"Mana Pool: {self.mana_pool}\n"
                f"Hand: {[card.name for card in self.hand]}\n"
                f"Battlefield: {[card.name for card in self.battlefield]}\n"
                f"Graveyard: {[card.name for card in self.graveyard]}")


# Example Usage
if __name__ == "__main__":
    # Create a player
    player1 = Player("Alice")

    # Add mana using shorthand and full names interchangeably
    player1.mana_pool.add_mana("White", 2)  # Using full name
    player1.mana_pool.add_mana("G", 3)      # Using shorthand

    # Create some cards with costs in mixed syntax
    card1 = Card("Serra Angel", {"White": 2, "C": 3}, "Creature")
    card2 = Card("Llanowar Elves", {"G": 1}, "Creature")
    card3 = Card("Counterspell", {"U": 2}, "Instant")

    # Add cards to the player's hand
    player1.hand.extend([card1, card2, card3])

    # Display the player's state
    print(player1)

    # Attempt to play some cards
    player1.play_card(card1)  # Should fail (not enough colorless mana)
    player1.play_card(card2)  # Should succeed (enough green mana)

    # Display the updated state
    print(player1)
