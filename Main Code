# Mana color mapping for shorthand and full names
MANA_COLORS = {"White": "W", "Blue": "U", "Black": "B", "Red": "R", "Green": "G", "Colorless": "C"}
MANA_COLOR_MAP = {**MANA_COLORS, **{v: k for k, v in MANA_COLORS.items()}}  # Bidirectional mapping


def normalize_mana_color(input_color):
    """
    Normalize a mana color input to its shorthand representation.
    If the input is already shorthand, return it as is.
    """
    if input_color in MANA_COLOR_MAP:
        # Always return the shorthand version
        return MANA_COLORS.get(input_color, input_color)
    else:
        raise ValueError(f"Invalid mana color: {input_color}")


# Predefined card types, supertypes, and subtypes
CARD_TYPES = [
    "Artifact", "Battle", "Conspiracy", "Creature", "Dungeon",
    "Enchantment", "Instant", "Kindred", "Land", "Phenomenon",
    "Plane", "Planeswalker", "Scheme", "Sorcery", "Vanguard"
]

CARD_SUPERTYPES = ["Legendary", "Basic", "Snow", "World", "Ongoing"]

# A dictionary of predefined subtypes for demonstration
CARD_SUBTYPES = {
    "Creature": ["Rat", "Elf", "Zombie", "Angel", "Dragon"],
    "Land": ["Forest", "Island", "Swamp", "Mountain", "Plains"],
    "Enchantment": ["Aura", "Room", "Shrine"],
    "Artifact": ["Equipment", "Vehicle"],
    "Planeswalker": ["Ajani", "Liliana", "Teferi"],
    "Sorcery": ["Arcane"]
}


class Card:
    """
    Represents a Magic: The Gathering card with support for types, supertypes, and subtypes.
    """
    def __init__(self, name, cost, types, subtypes=None, supertypes=None):
        self.name = name
        self.cost = {normalize_mana_color(color): amount for color, amount in cost.items()}
        self.types = [t.capitalize() for t in types if t.capitalize() in CARD_TYPES]
        self.subtypes = [s.capitalize() for s in (subtypes or [])]
        self.supertypes = [s.capitalize() for s in (supertypes or [])]
        self.tapped = False
        self.zone = "Library"

    def get_full_type(self):
        """
        Returns the full type line of the card (supertypes, types, and subtypes).
        Example: "Legendary Creature - Rat"
        """
        type_line = " ".join(self.supertypes + self.types)
        if self.subtypes:
            type_line += " - " + ", ".join(self.subtypes)
        return type_line

    def is_playable(self, mana_pool):
        for color, amount in self.cost.items():
            if mana_pool.pool.get(color, 0) < amount:
                return False
        return True

    def __str__(self):
        cost_str = ", ".join(f"{MANA_COLOR_MAP[color]}: {amount}" for color, amount in self.cost.items() if amount > 0)
        tapped_status = "Tapped" if self.tapped else "Untapped"
        return (f"{self.name} ({self.get_full_type()}) - Cost: {cost_str}, "
                f"Status: {tapped_status}, Zone: {self.zone}")


class ManaPool:
    """
    Represents a player's mana pool.
    Supports adding, spending, and resetting mana of all valid colors.
    """
    def __init__(self):
        self.pool = {color: 0 for color in MANA_COLORS.values()}

    def add_mana(self, color, amount=1):
        normalized_color = normalize_mana_color(color)
        if normalized_color in self.pool:
            self.pool[normalized_color] += amount
            print(f"Added {amount} {MANA_COLOR_MAP[normalized_color]} mana. Current mana pool: {self}")
        else:
            print(f"Invalid mana color: {color}")

    def spend_mana(self, cost):
        """
        Spend mana from the pool if sufficient mana is available.
        The cost is a dictionary: {"White": 1, "Green": 2, ...}.
        """
        normalized_cost = {normalize_mana_color(color): amount for color, amount in cost.items()}

        # Check if the cost can be paid
        for color, amount in normalized_cost.items():
            if self.pool.get(color, 0) < amount:
                print(f"Not enough {MANA_COLOR_MAP[color]} mana to pay the cost!")
                return False

        # Deduct the mana
        for color, amount in normalized_cost.items():
            self.pool[color] -= amount
        print(f"Mana spent: {normalized_cost}. Remaining pool: {self}")
        return True

    def reset_pool(self):
        self.pool = {color: 0 for color in self.pool}
        print("Mana pool has been reset.")

    def __str__(self):
        return ", ".join(f"{color}: {amount}" for color, amount in self.pool.items() if amount > 0)


class Player:
    """
    Represents a player with a mana pool, hand, library, battlefield, and graveyard.
    """
    def __init__(self, name):
        self.name = name
        self.life_total = 20
        self.mana_pool = ManaPool()
        self.library = []
        self.hand = []
        self.battlefield = []
        self.graveyard = []

    def draw_card(self):
        """Draw a card from the library and add it to the hand."""
        if self.library:
            card = self.library.pop(0)
            self.hand.append(card)
            card.zone = "Hand"
            print(f"{self.name} drew {card.name}.")
        else:
            print(f"{self.name} has no cards left in the library!")

    def play_card(self, card):
        """
        Attempt to play a card from the hand. If successful, pay its cost and move it to the battlefield.
        """
        if card in self.hand and card.is_playable(self.mana_pool):
            self.mana_pool.spend_mana(card.cost)
            self.hand.remove(card)
            self.battlefield.append(card)
            card.zone = "Battlefield"
            print(f"{self.name} played {card.name}.")
        else:
            print(f"{self.name} cannot play {card.name} (not enough mana or not in hand).")

    def __str__(self):
        """Return the player's current state."""
        return (f"Player: {self.name}, Life Total: {self.life_total}\n"
                f"Mana Pool: {self.mana_pool}\n"
                f"Hand: {[card.name for card in self.hand]}\n"
                f"Battlefield: {[card.name for card in self.battlefield]}\n"
                f"Graveyard: {[card.name for card in self.graveyard]}")


# Example Usage
if __name__ == "__main__":
    # Create a player
    player1 = Player("Craig")

    # Add mana
    player1.mana_pool.add_mana("White", 2)
    player1.mana_pool.add_mana("G", 3)

    # Create some cards
    card1 = Card("Serra Angel", {"W": 2, "C": 3}, ["Creature"], ["Angel"], ["Legendary"])
    card2 = Card("Llanowar Elves", {"G": 1}, ["Creature"], ["Elf"])
    card3 = Card("Swords to Plowshares", {"W": 1}, ["Instant"])

    # Add cards to the player's hand
    player1.hand.extend([card1, card2, card3])

    # Display the player's state
    print(player1)

    # Attempt to play some cards
    player1.play_card(card1)
    player1.play_card(card2)

    # Display the updated state
    print(player1)
